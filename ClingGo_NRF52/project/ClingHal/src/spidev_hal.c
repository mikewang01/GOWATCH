#include <btle_api.h>
/******************************************************************************
 #include <spidev_hal.h>
 #include <spidev_hal.h>
 * Copyright 2013-2016 hicling Systems (MikeWang)
 *
 * FileName: rtc_hal.c
 *
 * Description: abstract layer between cling sdk and freertos.
 *
 * Modification history:
 *     2016/7/22, v1.0 create this file mike.
 *******************************************************************************/
#include "oop_hal.h"
#include "rtc_hal.h"
#include "osal.h"
#include "main.h"
#include "stdio.h"
#include "string.h"
#include "main.h"
#include "pin_names.h"
#include "spidev_hal.h"
#include "nrf_drv_spi.h"
#ifdef __cplusplus
extern "C" {
#endif
//               .bus_id = NRF_DRV_SPI_INSTANCE(bus) ,\
//								.hw_init.bit_order = bit_order,
#undef 		SPI_SLAVE_DEVICE
#define SPI_SLAVE_DEVICE(bus, name, cs_port, cs_pin, _word_mode, spi_mode, spi_rate, bit_order_t) \
        const spi_device_config dev_##name = { \
								.bus_id = NRF_DRV_SPI_INSTANCE(0) ,\
								.hw_init.frequency = spi_rate,\
								.hw_init.irq_priority = bus##_IRQ,\
								.hw_init.miso_pin = GPIO_SPI_MISO,\
								.hw_init.mode = spi_mode,\
								.hw_init.mosi_pin = GPIO_SPI_MOSI,\
								.hw_init.sck_pin = GPIO_SPI_SCK,\
								.hw_init.ss_pin = cs_pin,\
								.hw_init.bit_order = bit_order_t, \
								.hw_init.orc       = 0x5A,\
        }; \
				const void *const name = &dev_##name;
						
/**
 * \brief SPI device constant data
 *
 * Variable of this type keeps static configuration needed to access device on SPI bus.
 * Those variables are generated by \sa SPI_SLAVE_DEVICE() and \sa SPI_SLAVE_TO_EXT_MASTER() macros.
 *
 */
#define HW_SPI_ID nrf_drv_spi_t
typedef struct spi_device_config {
        HW_SPI_ID bus_id;               /**< SPI id as needed by hw_spi_... functions */
        nrf_drv_spi_config_t hw_init;
        bool ignore_cs;                 /**< true if in slave mode CS line should be ignored */
} spi_device_config;

struct spi_bus_resouce{
		CLASS(SpiDevHal) *p_instance;
		OS_MUTEX  res_lock;
		OS_EVENT  bus_busy;
		uint16_t  ref_count;
		OS_TASK 	owner;
		spi_device_config *cur_dev_cfg;/*use to record current device config*/
};
/*********************************************************************
 * GLOBAL VARIABLES
 */

#include "flatform_dev.h"
/*********************************************************************
 * LOCAL VARIABLES
 */
static CLASS(SpiDevHal) *p_instance = NULL;
static struct spi_bus_resouce spi_res_mgr= {
	.p_instance = NULL,
	.cur_dev_cfg = NULL,
};
/*********************************************************************
 * LOCAL DECLARATION
 */
// #define SPI_BUS_DEVICE_NAME uint32_t
static int write_read(CLASS(SpiDevHal) *arg, spi_dev_handle_t hdl, uint8_t *p_txbuf, size_t tx_size,
        uint8_t *p_rxbuf, size_t rx_size);
static int read(CLASS(SpiDevHal) *arg, spi_dev_handle_t hdl, uint8_t *p_buf, size_t size);
static int write(CLASS(SpiDevHal) *arg, spi_dev_handle_t hdl, uint8_t *p_buf, size_t size);
static int open(CLASS(SpiDevHal) *arg);
static int close(CLASS(SpiDevHal) *arg, spi_dev_handle_t hdl);
static spi_dev_handle_t acc_open(CLASS(SpiDevHal) *arg);
static spi_dev_handle_t oled_open(CLASS(SpiDevHal) *arg);
static spi_dev_handle_t flash_open(CLASS(SpiDevHal) *arg);
/******************************************************************************
 * FunctionName : SpiDevHal_init
 * Description  : SpiDevHal object constuction function
 * Parameters   : CLASS(SpiDevHal) *arg: object pointer
 * Returns          : 0: sucess
 *                   -1: error
 *******************************************************************************/

static int SpiDevHal_init(CLASS(SpiDevHal) *arg)
{
        if (arg == NULL) {
                return -1;
        }
#if IS_SPI_ACC_SENSOR_SUPPORTED
        arg->acc_open = acc_open;
#endif
				arg->flash_open = flash_open;
        arg->read = read;
        arg->write = write;
        arg->write_read = write_read;
        arg->close = close;
				
        //ad_spi_init();
      //  SPI_BUS_INIT(SPI1);
				if(OS_MUTEX_CREATE(spi_res_mgr.res_lock) == false){
						
				}
				OS_EVENT_CREATE(spi_res_mgr.bus_busy);
				spi_res_mgr.ref_count = 0;
				spi_res_mgr.owner = NULL;
#if IS_SPI_ACC_SENSOR_SUPPORTED
				arg->oled_open = oled_open;
     //   SPI_DEVICE_INIT(ACC_SENSOR);
#endif
#if IS_SPI_OLED_SUPPORTED
       // SPI_DEVICE_INIT(OLED);
#endif
        return 0;
}

/******************************************************************************
 * FunctionName : SpiDevHal_get_instance
 * Description  : for user to get single instance object pointer
 * Parameters   : none
 * Returns          : 0: sucess
 *                   -1: error
 *******************************************************************************/

CLASS(SpiDevHal)* SpiDevHal_get_instance(void)
{
        static CLASS(SpiDevHal) p;
        if (spi_res_mgr.p_instance == NULL) {
                spi_res_mgr.p_instance = &p;
                memset(&p, 0, sizeof(p));
                SpiDevHal_init(spi_res_mgr.p_instance);
        }
        return spi_res_mgr.p_instance;
}

/******************************************************************************
 * FunctionName :btle_fsm_process
 * Description  : fsm
 * Parameters   : write: write call back function
 * Returns          : 0: sucess
 -1: error
 *******************************************************************************/

static int open(CLASS(SpiDevHal) *arg)
{
				int ret  = 0;
				/*resouce has been taken*/
				if(spi_res_mgr.ref_count > 0){
						/*this means same task request resource here*/
						if(OS_GET_CURRENT_TASK() == spi_res_mgr.owner){
								spi_res_mgr.ref_count ++;
						}else{
								OS_MUTEX_GET(spi_res_mgr.res_lock, OS_MUTEX_FOREVER);
								//ret = -1;
						}
				}else{
						OS_MUTEX_GET(spi_res_mgr.res_lock, OS_MUTEX_FOREVER);
						spi_res_mgr.owner = OS_GET_CURRENT_TASK();
						spi_res_mgr.ref_count ++;
				}
        return ret;//ad_spi_open(dev_id);
}
#if IS_SPI_ACC_SENSOR_SUPPORTED
static spi_dev_handle_t acc_open(CLASS(SpiDevHal) *arg)
{
				/*request spi resouce sucessfully*/
			spi_dev_handle_t* t = (spi_dev_handle_t*)ACC;
			 if(open(arg) >= 0){
					  return (spi_dev_handle_t*)ACC;
			 }else{
						return NULL;//ad_spi_open(ACC_SENSOR);
			 }
}
#endif

#if IS_SPI_OLED_SUPPORTED
static spi_dev_handle_t oled_open(CLASS(SpiDevHal) *arg)
{
	    /*request spi resouce sucessfully*/
			spi_dev_handle_t* t = (spi_dev_handle_t*)OLED;
			 if(open(arg) >= 0){
					  return (spi_dev_handle_t*)OLED;
			 }else{
						return NULL;//ad_spi_open(ACC_SENSOR);
			 }
}
#endif


static spi_dev_handle_t flash_open(CLASS(SpiDevHal) *arg)
{
				
			spi_dev_handle_t* t = (spi_dev_handle_t*)FLASH;
			if(open(arg) >= 0){
				return (spi_dev_handle_t*)FLASH;//ad_spi_open(OLED);
			}else{
				return NULL;
			}
}

static int write(CLASS(SpiDevHal) *arg, spi_dev_handle_t hdl, uint8_t *p_buf, size_t size)
{
       // ad_spi_write(hdl, p_buf, size);
				spi_device_config *t = (spi_device_config*)(hdl);
				if(spi_res_mgr.cur_dev_cfg != t){
						spi_res_mgr.cur_dev_cfg = t;
					  //nrf_drv_spi_uninit(&(spi_res_mgr.cur_dev_cfg->bus_id));
						nrf_drv_spi_init(&(spi_res_mgr.cur_dev_cfg->bus_id), &(spi_res_mgr.cur_dev_cfg->hw_init),NULL);
				}
        return 0;
}

static int read(CLASS(SpiDevHal) *arg, spi_dev_handle_t hdl, uint8_t *p_buf, size_t size)
{
        //ad_spi_read(hdl, p_buf, size);
        return 0;
}

void spi_master_0_event_handler(nrf_drv_spi_evt_t const * event)
{
	OS_EVENT_SIGNAL_FROM_ISR(spi_res_mgr.bus_busy);
}
static int write_read(CLASS(SpiDevHal) *arg, spi_dev_handle_t hdl, uint8_t *p_txbuf, size_t tx_size,
        uint8_t *p_rxbuf, size_t rx_size)
{ 
				/*if no hanlder provided , then just return error code*/
				if(hdl == NULL){
						return -1;
				}
				spi_device_config *t = (spi_device_config*)(hdl);
				if(spi_res_mgr.cur_dev_cfg != t){
						spi_res_mgr.cur_dev_cfg = t;
					  nrf_drv_spi_uninit(&(spi_res_mgr.cur_dev_cfg->bus_id));
						nrf_drv_spi_init(&(spi_res_mgr.cur_dev_cfg->bus_id), &(spi_res_mgr.cur_dev_cfg->hw_init),spi_master_0_event_handler);
				}
				nrf_drv_spi_transfer(&(spi_res_mgr.cur_dev_cfg->bus_id), p_txbuf, tx_size, p_rxbuf, rx_size);
				int  result = OS_EVENT_WAIT(spi_res_mgr.bus_busy, OS_MS_2_TICKS(5000));
				if(result == pdFALSE){
					/*if event wait timeout event happened*/
					return -1;
				}
				
				return 0;
				
       // ad_spi_transact(hdl, p_txbuf, tx_size, p_rxbuf, rx_size);
}

static int close(CLASS(SpiDevHal) *arg, spi_dev_handle_t hdl)
{
        //ad_spi_close(hdl);
				int ret  = 0;
				/*resouce has been taken*/
				if(spi_res_mgr.ref_count > 0){
						spi_res_mgr.ref_count --;
						/*this means same task request resource here*/
						if(spi_res_mgr.ref_count == 0){
								//spi_res_mgr.ref_count ++;
								OS_MUTEX_PUT(spi_res_mgr.res_lock);
						}
				}
        return ret;//ad_spi_open(dev_id);			
}

#ifdef __cplusplus
}
#endif
